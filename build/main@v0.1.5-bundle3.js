window.__nefbl_pack__bundleSrc__[25]=function(){var n,r={};var e=window.__nefbl_pack__getBundle("1").Component,t=window.__nefbl_pack__getBundle("47").default,l=e({selector:"Eliminate-Recursion",template:window.__nefbl_pack__getBundle("48").default,styles:[t]})(n=function n(){!function(n,r){if(!(n instanceof r))throw new TypeError("Cannot call a class as a function")}(this,n)})||n;return r.default=l,r},window.__nefbl_pack__bundleSrc__[47]=function(){var n={};return n.default="",n},window.__nefbl_pack__bundleSrc__[48]=function(){var n={};return n.default='<div class=\'doc-view\'>\r\n    <h2>\r\n        借助一个数组消除递归\r\n        <div>\r\n            （以自定义一个outerHTML为例）\r\n        </div>\r\n    </h2>\r\n    <p>\r\n        现在的需求是这样的：有一个DOM节点，我们希望获取其outerHTML，但是由于个别浏览器不支持这个属性，因此需要做polyfill进行兼容。\r\n    </p>\r\n    <p>\r\n        比如可以采用递归的方式快速实现：\r\n    </p>\r\n    <pre ui-code>\r\nfunction getTemplate(node){\r\n\r\n    如果是结点:\r\n\r\n        template="<结点>"\r\n        循环每个孩子：\r\n            template+=getTemplate(孩子结点)\r\n        return template+="</结点>"\r\n\r\n    如果是文本：\r\n        return 文本自身\r\n}\r\n    </pre>\r\n    <p>\r\n        可以看到，如果孩子层次比较深，对于每一个节点而言，在孩子解析完成前，自己都无法被释放（主要是局部变量等），这会导致一定的资源浪费。\r\n    </p>\r\n    <p>\r\n        其实，我们可以借助消耗一个一维数组来消除递归。\r\n    </p>\r\n    <pre ui-code>\r\nneedCalcs=[结点]\r\nindex=0\r\n\r\nwhile (index < needCalcs.length) {\r\n    从index开始，寻找到第一个结点\r\n        如果到结尾都没有，结束\r\n        否则：\r\n            如果是结点：\r\n                在当前index位置插入结点开始部分、孩子结点们、结点结束部分\r\n            否则：\r\n                把当前文本结点插入index位置即可\r\n}\r\n\r\ntemplate=needCalcs.join("")\r\n    </pre>\r\n    <p class=\'warn\'>\r\n        温馨提示：此处可能借助innerHTML来更简单，我们主要是提供一种思路，实际运用的时候，还需要考虑编程环境所提供的资源。\r\n    </p>\r\n    <p>\r\n        其实，在遍历树图的时候，借助一个数组或多个来实现遍历是很有用的思路，虽然在大部分的情况下，递归的写法相对更简单，但非递归除了可以节约资源外，调试也更方便。\r\n    </p>\r\n    <a class=\'open-demo\' target="_blank"\r\n        href="https://github.com/hai2007/xhtml-engine/blob/master/src/.inner/template.js">\r\n        查看用例>>>\r\n    </a>\r\n</div>\r\n',n};